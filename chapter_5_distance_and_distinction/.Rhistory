pivot_wider(names_from = word, values_from = freq, values_fill = 0) %>%
column_to_rownames("booktitle") %>%
as.matrix()
# Compute JSD for each pair of books
book_names <- rownames(freq_matrix)
n_books <- nrow(freq_matrix)
jsd_matrix <- matrix(0, n_books, n_books)
rownames(jsd_matrix) <- book_names
colnames(jsd_matrix) <- book_names
for (i in 1:n_books) {
for (j in 1:n_books) {
jsd_matrix[i, j] <- jsd(freq_matrix[i, ], freq_matrix[j, ])
}
}
# View results
kable(jsd_matrix)
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
distinctively_carroll <- tfidf_table %>%
filter(document == "Lewis Carroll") %>%
arrange(desc(tf_idf)) %>%
select(term, tf_idf)
knitr::opts_chunk$set(echo = TRUE)
# URLs for plain text versions
looking_glass_url <- "https://www.gutenberg.org/files/12/12-0.txt"
peter_url <- "https://www.gutenberg.org/cache/epub/14838/pg14838.txt"
# Extract "Through the Looking-Glass" and save it to RStudio's global environment
looking_glass_text <- readLines(looking_glass_url, encoding = "UTF-8", warn = FALSE)
# Extract "The Tale of Peter Rabbit" and save it to RStudio's global environment
peter_text <- readLines(peter_url, encoding = "UTF-8", warn = FALSE)
# Load required libraries
library(tidyverse)
library(tidytext)
# Convert to data frames
looking_glass_df <- tibble(writer = "Lewis Carroll", text = looking_glass_text)
peter_df <- tibble(writer = "Beatrix Potter", text = peter_text)
# Combine both texts
books <- bind_rows(looking_glass_df, peter_df)
# Tokenize text by spliting it into individual words
tokens <- books %>%
unnest_tokens(word, text) %>%
filter(str_detect(word, "^[a-z']+$"))  # keep only alphabetic words
# Calculate word frequencies per author
word_counts <- tokens %>%
count(writer, word) %>%
pivot_wider(names_from = word, values_from = n, values_fill = 0)
# Focus on selected words of interest
target_words <- c("rabbit", "she", "little", "chortled", "shed", "the", "hoe", "slithy", "galumph")
selected <- word_counts %>%
select(writer, any_of(target_words))
# View the table
print(selected)
# Count word frequencies per author (long format)
word_counts2 <- tokens %>%
count(writer, word, sort = TRUE) %>%
rename(document = writer, term = word)
# Compute tf-idf values
tfidf_table <- word_counts2 %>%
bind_tf_idf(term = term, document = document, n = n)
# View top distinctive words for each author
filtered_tfidf <- tfidf_table %>%
filter(term %in% target_words) %>%
arrange(document, desc(tf_idf)) %>%
select(term, tf_idf)
library(knitr)
make_tab <- function(df) {
df %>%
mutate(tf_idf = round(as.numeric(tf_idf), 6)) %>%
kable(format = "latex", booktabs = TRUE, caption = NULL,
col.names = c("Word", "TF-IDF")) %>%
as.character() }
left_tab  <- make_tab(filtered_tfidf[1:6, ])
right_tab <- make_tab(filtered_tfidf[7:12, ])
two_pane_table <- paste0(
"\\noindent
\\begin{minipage}[t]{0.48\\textwidth}
\\raggedright\\textbf{Some Beatrix Potter Words}\\\\[3pt]",
left_tab, "
\\end{minipage}\\hfill
\\begin{minipage}[t]{0.48\\textwidth}
\\raggedright\\textbf{Some Lewis Carroll Words}\\\\[3pt]",
right_tab, "
\\end{minipage}")
asis_output(two_pane_table)
library(kableExtra)
distinctively_carroll <- tfidf_table %>%
filter(document == "Lewis Carroll") %>%
arrange(desc(tf_idf)) %>%
select(term, tf_idf)
kable(head(distinctively_carroll, 15),
format = "latex",
booktabs = TRUE,
caption = "\\textbf{\\large Lewis Carroll's Most Distinctive Words (when \\textit{Alice} is Compared with \\textit{Peter Rabbit})}",
col.names = c("Word", "TF-IDF"),   # <-- THIS IS THE FIX
escape = FALSE) %>%
kable_styling(full_width = TRUE)
library(text2vec)             # Load the package
# define a function for jsd
jsd <- function(p, q) {
# Ensure p and q are probability distributions
p <- p / sum(p)
q <- q / sum(q)
m <- 0.5 * (p + q)
# Define a helper function for KL divergence
kl_div <- function(a, b) {
a <- ifelse(a == 0, 1, a)  # Avoid log(0)
b <- ifelse(b == 0, 1, b)
sum(a * log2(a / b)) }
0.5 * kl_div(p, m) + 0.5 * kl_div(q, m) }
# load Alice in Wonderland
alice_url <- "https://www.gutenberg.org/files/11/11-0.txt"
alice_text <- readLines(alice_url, encoding = "UTF-8", warn = FALSE)
# Combine into one data frame
books <- bind_rows(
tibble(booktitle = "Alice", text = alice_text),
tibble(booktitle = "Peter", text = peter_text),
tibble(booktitle = "LookingGlass", text = looking_glass_text))
# Tokenise and count
word_freqs <- books %>%
unnest_tokens(word, text) %>%
filter(str_detect(word, "^[a-z']+$")) %>%
count(booktitle, word) %>%
group_by(booktitle) %>%
mutate(freq = n / sum(n)) %>%
ungroup()
# Create a frequency matrix (book x word)
freq_matrix <- word_freqs %>%
select(booktitle, word, freq) %>%
pivot_wider(names_from = word, values_from = freq, values_fill = 0) %>%
column_to_rownames("booktitle") %>%
as.matrix()
# Compute JSD for each pair of books
book_names <- rownames(freq_matrix)
n_books <- nrow(freq_matrix)
jsd_matrix <- matrix(0, n_books, n_books)
rownames(jsd_matrix) <- book_names
colnames(jsd_matrix) <- book_names
for (i in 1:n_books) {
for (j in 1:n_books) {
jsd_matrix[i, j] <- jsd(freq_matrix[i, ], freq_matrix[j, ]) } }
# View results
kable(jsd_matrix)
# Load our needed R packages
library(hansardr)
library(tidyverse)
library(lubridate)
library(tidytext)
library(gt)
# Load tidytext's built-in list of stop words for filtering out common words
data("stop_words")
# Load the Hansard debates from the 1830s and 1860s
data("hansard_1830")
data("hansard_1860")
# Add a 'decade' column to hansard_1830 to tag all rows with the value 1830
hansard_1830 <- hansard_1830 %>%
mutate(decade = 1830)
# Add a 'decade' column to hansard_1860 to tag all rows with the value 1860
hansard_1860 <- hansard_1860 %>%
mutate(decade = 1860)
# Combine the two Hansard datasets by stacking their rows into one data frame
# 1830 will be stacked above 1860
hansard_data <- bind_rows(hansard_1830, hansard_1860)
# Inspect the data
hansard_data[, 2:3] %>%
sample_n(5) %>%
kable(format = "latex", booktabs = TRUE,
caption = "Sample from Hansard Data") %>%
kable_styling(latex_options = "hold_position")
# Code does not show, just output
tokenized_hansard_data <- suppressMessages(
hansard_data %>%
unnest_tokens(word, text) %>%
anti_join(stop_words) %>%
filter(!str_detect(word, "[[:digit:]]")))
# tokenize the 'text' column into individual words,
# remove stop words, and filter out tokens that contain digits
tokenized_hansard_data <- hansard_data %>%
unnest_tokens(word, text) %>% # break text into one word per row
anti_join(stop_words) %>% # remove stop words like 'the' or 'and'
filter(!str_detect(word, "[:digit:]")) # remove words with digits
# count how often each word appears per decade,
# sort by frequency, and remove words that appear only once
words_per_decade <- tokenized_hansard_data %>%
count(decade, word, sort = TRUE, name = "word_count_per_decade") %>%  # count word frequency by decade
filter(word_count_per_decade > 1)  # keep words that appear more than once
# Inspect the data
words_per_decade %>%
rename(hansard_word = word, hansard_decade = decade) %>%
sample_n(8) %>%
arrange(desc(word_count_per_decade)) %>%
pivot_wider(names_from = hansard_word, values_from = word_count_per_decade,
values_fill = 0)
# calculate tf-idf (term frequency–inverse document frequency) for each word by decade
# using word frequency and total count
hansard_tf_idf <- words_per_decade %>%
bind_tf_idf(word, decade, word_count_per_decade)  # compute tf-idf \
hansard_tf_idf %>%
sample_n(5) %>%
arrange(desc(tf_idf))
# keep top 15 tf-idf words per decade
top_hansard_tf_idf <- hansard_tf_idf %>%
group_by(decade) %>% # group by decade
slice_max(tf_idf, n = 15) %>% # keep top 15 words
arrange(decade, desc(tf_idf)) %>%
ungroup()
# ---- Packages ----
suppressPackageStartupMessages({
library(dplyr)
library(purrr)
library(knitr)
library(kableExtra)
library(glue)
library(stringi)
})
# ---- 0) Build top_hansard_tf_idf if missing (else use your existing one) ----
if (!exists("top_hansard_tf_idf") && exists("hansard_tf_idf")) {
top_hansard_tf_idf <- hansard_tf_idf %>%
group_by(decade) %>%
slice_max(tf_idf, n = 15) %>%
arrange(decade, desc(tf_idf)) %>%
ungroup()
}
# ---- 1) Unicode sanitizer (handles U+07DE and common arrows) ----
sanitize_text <- function(x) {
if (!is.character(x)) return(x)
x <- stri_replace_all_fixed(x, "\u07DE", "")      # strip N’Ko ߞ
x <- stri_replace_all_fixed(x, "\u2192", "->")    # → to ASCII
x <- stri_trans_general(x, "Any-Latin; Latin-ASCII")  # general fallback
x
}
sanitize_df <- function(df) {
df %>% mutate(across(where(is.character), sanitize_text))
}
# ---- 2) Ensure data is clean before table creation ----
stopifnot(exists("top_hansard_tf_idf"))
top_hansard_tf_idf <- top_hansard_tf_idf %>% sanitize_df()
# ---- 3) Make a pure LaTeX tabular (safe inside minipage) ----
make_kable_tabular <- function(df) {
k <- df %>%
select(word, tf_idf) %>%
mutate(
word   = sanitize_text(word),
tf_idf = round(tf_idf, 6)
) %>%
knitr::kable(
format = "latex",
booktabs = TRUE,
col.names = c("Word", "tf-idf Score"),
align = c("l", "r"),
escape = TRUE
) %>%
kable_styling() %>%
as.character()
# Keep only the tabular body (strip floating table env)
k <- sub(".*?\\begin\{tabular\}", "\\begin{tabular}", k, perl = TRUE)
library(dplyr)
library(purrr)
library(knitr)
library(kableExtra)
library(glue)
library(stringr)
# 1) Helper: make a raw LaTeX tabular (no floating table env)
make_kable_tabular <- function(df) {
k <- df %>%
select(word, tf_idf) %>%
mutate(tf_idf = round(tf_idf, 6)) %>%
knitr::kable(
format = "latex",
booktabs = TRUE,
col.names = c("Word", "tf-idf Score"),
align = c("l", "r")
) %>%
kable_styling() %>%
as.character()
# Strip the outer \begin{table}...\end{table} so it's minipage-safe
# keep only the tabular body
k <- sub(R"(.*?\\begin\{tabular\})", R"(\\begin{tabular})", k, perl = TRUE)
k <- sub(R"(\\end\{tabular\}.*$)",   R"(\\end{tabular})",   k, perl = TRUE)
k
}
# 2) Build a kable tabular per decade
tabs <- top_hansard_tf_idf %>%
group_by(decade) %>%
group_split() %>%
map(function(df) {
list(
decade = unique(df$decade),
tabular = make_kable_tabular(df)
)
})
# 3) Global heading (LaTeX-safe)
knitr::asis_output("\\section*{The Words Most Distinctive of the 1830s and 1860s}\nWhen the decades are compared with each other.\n\n")
# 4) Emit side-by-side in 2 columns using minipage
idx_pairs <- split(seq_along(tabs), ceiling(seq_along(tabs) / 2))
walk(idx_pairs, function(ix) {
left  <- tabs[[ix[1]]]
right <- if (length(ix) == 2) tabs[[ix[2]]] else NULL
left_block <- glue(
"\\begin{{minipage}}[t]{{0.48\\textwidth}}
\\textbf{{Top tf-idf Words — {left$decade}}}\\\\[0.5ex]
{left$tabular}
\\end{{minipage}}"
)
right_block <- if (!is.null(right)) glue(
"\\hfill
\\begin{{minipage}}[t]{{0.48\\textwidth}}
\\textbf{{Top tf-idf Words — {right$decade}}}\\\\[0.5ex]
{right$tabular}
\\end{{minipage}}"
) else ""
knitr::asis_output(paste0(left_block, "\n", right_block, "\n\n"))
})
library(dplyr)
library(purrr)
library(knitr)
library(kableExtra)
library(glue)
library(stringr)
# 1) Helper: make a raw LaTeX tabular (no floating table env)
make_kable_tabular <- function(df) {
k <- df %>%
select(word, tf_idf) %>%
mutate(tf_idf = round(as.numeric(tf_idf), 6)) %>%
knitr::kable(
format = "latex",
booktabs = TRUE,
col.names = c("Word", "TF--IDF Score"),
align = c("l", "r")
) %>%
kable_styling() %>%
as.character()
# Strip any outer \begin{table}...\end{table} so it's minipage-safe
k <- sub(r"(.*?\\begin\{tabular\})", r"(\\begin{tabular})", k, perl = TRUE)
k <- sub(r"(\\end\{tabular\}.*$)",   r"(\\end{tabular})",   k, perl = TRUE)
k
}
# 2) Build a kable tabular per decade
tabs <- top_hansard_tf_idf %>%
group_by(decade) %>%
group_split() %>%
map(function(df) {
list(
decade  = unique(df$decade),
tabular = make_kable_tabular(df)
)
})
# 3) Global heading (LaTeX-safe)
knitr::asis_output("\\section*{The Words Most Distinctive of the 1830s and 1860s}\nWhen the decades are compared with each other.\n\n")
# 4) Emit side-by-side in 2 columns using minipage
idx_pairs <- split(seq_along(tabs), ceiling(seq_along(tabs) / 2))
walk(idx_pairs, function(ix) {
left  <- tabs[[ix[1]]]
right <- if (length(ix) == 2) tabs[[ix[2]]] else NULL
left_block <- glue(
"\\begin{{minipage}}[t]{{0.48\\textwidth}}
\\textbf{{Top TF--IDF Words --- {left$decade}}}\\\\[0.5ex]
{left$tabular}
\\end{{minipage}}"
)
right_block <- if (!is.null(right)) glue(
"\\hfill
\\begin{{minipage}}[t]{{0.48\\textwidth}}
\\textbf{{Top TF--IDF Words --- {right$decade}}}\\\\[0.5ex]
{right$tabular}
\\end{{minipage}}"
) else ""
knitr::asis_output(paste0(left_block, "\n", right_block, "\n\n"))
})
# libs you need
library(dplyr)
library(purrr)
library(glue)
library(knitr)
library(kableExtra)
# 1) Helper: make a raw LaTeX tabular (no floating table env)
make_kable_tabular <- function(df) {
df %>%
select(word, tf_idf) %>%
mutate(tf_idf = round(as.numeric(tf_idf), 6)) %>%
kableExtra::kbl(
format    = "latex",
booktabs  = TRUE,
col.names = c("Word", "TF--IDF Score"),
align     = c("l", "r"),
escape    = TRUE
) %>%
kableExtra::kable_styling() %>%
as.character()
}
# 2) Build a kable tabular per decade
tabs <- top_hansard_tf_idf %>%
group_by(decade) %>%
group_split() %>%
map(function(df) {
list(
decade  = unique(df$decade),
tabular = make_kable_tabular(df)
)
})
# 3) Global heading (LaTeX-safe)
knitr::asis_output(
"\\section*{The Words Most Distinctive of the 1830s and 1860s}\nWhen the decades are compared with each other.\n\n"
)
# 4) Emit side-by-side in 2 columns using minipage
idx_pairs <- split(seq_along(tabs), ceiling(seq_along(tabs) / 2))
walk(idx_pairs, function(ix) {
left  <- tabs[[ix[1]]]
right <- if (length(ix) == 2) tabs[[ix[2]]] else NULL
left_block <- glue(
"\\begin{{minipage}}[t]{{0.48\\textwidth}}
\\textbf{{Top TF--IDF Words --- {left$decade}}}\\\\[0.5ex]
{left$tabular}
\\end{{minipage}}"
)
right_block <- if (!is.null(right)) glue(
"\\hfill
\\begin{{minipage}}[t]{{0.48\\textwidth}}
\\textbf{{Top TF--IDF Words --- {right$decade}}}\\\\[0.5ex]
{right$tabular}
\\end{{minipage}}"
) else ""
knitr::asis_output(paste0(left_block, "\n", right_block, "\n\n"))
})
# libs you need
# ---- chunk header example ----
# ```{r, echo=FALSE}
# (put the code below in a chunk like this)
# ```
library(dplyr)
library(knitr)
library(kableExtra)
# Helper: make one LaTeX kable (non-floating tabular by default with kbl)
make_kable <- function(df, dec_label) {
df %>%
select(word, tf_idf) %>%
arrange(desc(tf_idf)) %>%
mutate(tf_idf = round(as.numeric(tf_idf), 6)) %>%
kableExtra::kbl(
format    = "latex",
booktabs  = TRUE,
col.names = c("Word", "TF--IDF Score"),
align     = c("l", "r"),
caption   = paste0("Top TF--IDF Words — ", dec_label),
escape    = TRUE
) %>%
kableExtra::kable_styling(full_width = FALSE)
}
# Choose the two decades you want
target_decades <- c("1830s", "1860s")   # or c(1830, 1860) if numeric in your data
# Build and print the two tables
top_hansard_tf_idf %>%
filter(decade %in% target_decades) %>%
group_by(decade) %>%
group_split() %>%
# make a kable for each decade, then print them one after another
lapply(function(df) make_kable(df, unique(df$decade))) %>%
lapply(print)
# libs you need
# ---- chunk header example ----
# ```{r, echo=FALSE}
# (put the code below in a chunk like this)
# ```
# ---- chunk header: {r, echo=FALSE} ----
library(dplyr)
library(knitr)
library(kableExtra)
make_kable <- function(df, dec_label) {
df %>%
select(word, tf_idf) %>%
arrange(desc(tf_idf)) %>%
mutate(tf_idf = round(as.numeric(tf_idf), 6)) %>%
kbl(
format    = "latex",
booktabs  = TRUE,
col.names = c("Word", "TF--IDF Score"),
align     = c("l", "r"),
caption   = paste0("Top TF--IDF Words — ", dec_label),
escape    = TRUE
) %>%
kable_styling(full_width = FALSE)
}
# Pick decades (auto-match type)
target_decades <- if (is.numeric(top_hansard_tf_idf$decade)) c(1830, 1860) else c("1830s", "1860s")
# Optional sanity check:
# print(dplyr::distinct(top_hansard_tf_idf, decade))
top_hansard_tf_idf %>%
filter(decade %in% target_decades) %>%
group_by(decade) %>%
group_walk(~ print(make_kable(.x, unique(.x$decade))))
# ---- chunk header: {r, echo=FALSE} ----
library(dplyr)
library(knitr)
library(kableExtra)
make_kable <- function(df, dec_label) {
df %>%
select(word, tf_idf) %>%
arrange(desc(tf_idf)) %>%
mutate(tf_idf = round(as.numeric(tf_idf), 6)) %>%
kbl(
format    = "latex",
booktabs  = TRUE,
col.names = c("Word", "TF--IDF Score"),
align     = c("l", "r"),
caption   = paste0("Top TF--IDF Words — ", dec_label),
escape    = TRUE
) %>%
kable_styling(full_width = FALSE)
}
# Optional: pick specific decades; otherwise render all present
# target_decades <- c("1830s","1860s")  # or c(1830,1860) if numeric
# df_in <- most_dist_hansard_words %>% filter(decade %in% target_decades)
df_in <- most_dist_hansard_words
